# Knapsack problem

>[!important]
> 包含兩種 0/1 背包 、 完整背包


## 0/1 背包

- 在背包重量**有限制**，每種物品**只能拿取一個或不拿(`0` or `1`)**，且要求**取出最多價值**

>使用二維陣列 `dp` 存取

>[!tip]
>## dp[i][w] 意義
>- i: 在 i 之前可拿的物品 (0 ~ i 之間選擇)
>- w: 目前負重 (0 ~ w 之間)
>- dp[i][w]: 目前可以獲得的最高價值

- 取法

```md
dp[i][w] =    // 不選第 i 個, // 選第 i 個
         = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])  
```

可以用一個範例來更直觀的看

```md
物品: [重量, 價值]
1: [2, 6]
2: [2, 10]
3: [3, 12]
容量: W = 5

dp 表：
      W=0  W=1  W=2  W=3  W=4  W=5
i=0   0    0    0    0    0    0
i=1   0    0    6    6    6    6
i=2   0    0    10   10   16   16
i=3   0    0    10   12   16   22

w=5, i=3 => 選取 3 號 ， w=5-3=2 所以去看 i=2, w=2 為 10 加上 3 的價值 12 => 22
```

## 完全背包

> 跟0/1背包不同之處在於`一個物品可以拿好幾次`


- 取法

```md
dp[i][w] = max(dp[i-1][w], dp[i][w-weight[i]] + value[i])
```


### 延伸: 0/1 背包記數版

1. 背包容量 = n

2. 每個物品重量 

3. 每個物品只能用一次

4. 我們不是求最大價值，而是求「湊出容量的組合數量」

這時 dp[i][w] 改成：

> 用前 i 個物品，容量 w，有幾種方法

```md
dp[i][w] = dp[i-1][w]                    // 不選第 i 個
         + dp[i-1][w - weight[i]]         // 選第 i 個
```